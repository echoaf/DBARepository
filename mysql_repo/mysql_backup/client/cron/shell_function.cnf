#!/bin/bash

# description:MySQL全备功能函数
# arthur
# 2018-10-16

base_dir="/data/repository/mysql_repo/mysql_backup"
shell_cnf="$base_dir/common/shell.cnf"
if [ ! -f "$shell_cnf" ] ;then
    echo "$0:找不到配置文件"
    exit 64
else
    source $shell_cnf
fi

#######################################
# 检测MySQL是否可以连接
# Globals:
#   None
# Arguments:
#   checkMySQLConnection "$mysql_host" "$mysql_port" "$mysql_user" "$mysql_pass" "$normal_log"
# Returns:
#   0:成功
#   64:失败
#######################################
function checkMySQLConnection()
{
    mysql_host="$1"
    mysql_port="$2"
    mysql_user="$3"
    mysql_pass="$4"
    normal_log="$5"
    value=$($mysql -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_pass -e "select 'k'" -N 2>&1)
    if [ "$value" == "k" ];then
        return 0
    else
        printLog "MySQL连接失败:$value" "$normal_log"
        return 64
    fi
    
}


#######################################
# mydumper备份前的检测
# Globals:
#   None
# Arguments:
#   mydumperCheck src_host src_port backup_path normal_log
# Returns:
#   0:Yes
#   64:No
function mydumperCheck()
{
    src_host="$1"
    src_port="$2"
    backup_path="$3"
    normal_log="$4"

    SRC_MYSQL="mysql -u$dump_user -p$dump_pass -h$src_host -P$src_port -N"

    printLog "===检测备份目录" "$normal_log"
    if [ ! -d "$backup_path" ];then
        printLog "备份目录'$backup_path'不存在" "$normal_log"
        return 64
    fi

    if (( $(ls "$backup_path"|wc -l)!=0 )) ;then
        printLog "备份目录'$backup_path'存在数据,请先清理掉" "$normal_log"
        return 64
    fi
    
    printLog "===检测数据库" "$normal_log"
    checkMySQLConnection "$src_host" "$src_port" "$dump_user" "$dump_pass" "$normal_log"
    if (($?!=0));then
        return 64
    fi
    checkMySQLConnection "$src_host" "$src_port" "$repl_user" "$repl_pass" "$normal_log"
    if (($?!=0));then
        return 64
    fi
    # Load需要检测
    #checkMySQLConnection "$dest_host" "$dest_port" "$admin_user" "$admin_pass" "$normal_log"
    #if (($?!==0));then
    #    return 64
    #fi

    printLog "===检测活跃连接数" "$normal_log"
    trx_count=$(echo "select count(*) from information_schema.innodb_trx;"| $SRC_MYSQL)
    ddl_count=$(echo "select count(*) from information_schema.processlist where user='auto_execute';"| $SRC_MYSQL)
    if ((${trx_count}>0));then
        printLog "[$sel_info] 当前存在活跃事务,退出" "$normal_log" "red"
        return 64
    fi
    if ((${ddl_count}>0));then
        printLog "[$sel_info] 当前存在ddl线程在执行,退出" "$normal_log" "red"
        return 64
    fi

    return 0
}



#######################################
# xtrbackup备份前的检测
# Globals:
#   None
# Arguments:
#    xtrabackupCheck $src_host $src_port $dest_host $dest_port $backup_path $src_ssh_port $dest_ssh_port $normal_log
# Returns:
#   0:Yes
#   64:No
:<<comment
B:备份机器
S:slave
M:master

1、xtrabackup执行逻辑
B->S
在B上执行ssh命令,把xtrabackup目录扔过去 /tmp/xtrabackup
S->M
在S上执行命令,远程执行调用M，然后M又需要把数据传输到S

2、检测逻辑

所有检测在B上执行:
B检测到S是否通
B检测S到M是否通
B检测M到S是否通

所以SSH密钥需要

1、B->S免密钥
2、S->M免密钥
3、M->S免密钥
comment

function xtrabackupCheck()
{
    src_host="$1"
    src_port="$2"
    dest_host="$3"
    dest_port="$4"
    backup_path="$5"
    src_ssh_port="$6"
    dest_ssh_port="$7"
    normal_log="$8"

    if [ ! -d "$backup_path" ];then
        printLog "备份目录'$backup_path'不存在" "$normal_log"
        return 64
    fi

    if (( $(ls "$backup_path"|wc -l)!=0 )) ;then
        printLog "备份目录'$backup_path'存在数据,请先清理掉" "$normal_log"
        return 64
    fi
    
    checkMySQLConnection "$src_host" "$src_port" "$dump_user" "$dump_pass" "$normal_log"
    if (($?!=0));then
        return 64
    fi
    checkMySQLConnection "$src_host" "$src_port" "$repl_user" "$repl_pass" "$normal_log"
    if (($?!=0));then
        return 64
    fi
    checkMySQLConnection "$dest_host" "$dest_port" "$admin_user" "$admin_pass" "$normal_log"
    if (($?!=64));then
        return 64
    fi

:<<comment
    B:ssh -p slave_port root@'slave_host' 'cmd1'
    S:cmd1=ssh -p master_port root@'master_host' 'cmd2'
    M:cmd2=ssh -p slave_port root@'slave_host' 'echo HELLO'
    src_ssh_port=22
    dest_ssh_port=22
    src_host=172.16.112.10
    dest_host=172.16.112.10
    
    cmd2="ssh -p $dest_ssh_port root@'$dest_host' 'echo HELLO'" # 在master上检测到slave是否通
    cmd1="ssh -p $src_ssh_port root@'$src_host' '$cmd2'" # 在slave上检测是否到master通
    echo "$cmd2"
    echo "$cmd1"
    value=$(ssh -p $dest_ssh_port root@"$dest_host" "$cmd1" 2>&1) # 在backup上检测到slave是否通
    echo "$value"
comment

    cmd2="ssh -p $dest_ssh_port root@'$dest_host' 'echo HELLO'" # 在master上检测到slave是否通
    cmd1="ssh -p $src_ssh_port root@'$src_host' '$cmd2'" # 在slave上检测是否到master通
    value=$(ssh -p $dest_ssh_port root@"$dest_host" "$cmd1" 2>&1) # 在backup上检测到slave是否通
    
    if [ "$value" != "HELLO" ];then
        printLog "ssh免密钥检测出错,exit,$value" "$normal_log"
        return 64
    fi
    
}




#######################################
# mydumper备份
# Globals:
#   None
# Arguments:
# is_wait 
#   Y:等待mydumper执行完,适用于在线搭建备机
#   N:不等待mydumper执行完,置于后台,适用于全备
# Returns:
#   0:Succ
#   64:Fail
function mydumperBackup()
{
    src_host="$1"
    src_port="$2"
    backup_path="$3"
    is_wait="$4"
    normal_log="$5"

    mydumperCheck $src_host $src_port $backup_path $normal_log
    if (($?!=0));then
        return 64
    fi
    
    sel_info="$src_host:$src_port"
    table_count=$(echo "select count(*) from information_schema.tables;"| $SRC_MYSQL)
    max_rows_count=$(echo "select count(*) from information_schema.tables where table_rows>'${max_table_rows}';"| $SRC_MYSQL)
    printLog "[$sel_info] ====开始备份,实例表总数:${table_count},大于${max_table_rows}行的表数目:${max_rows_count}" "$normal_log" "green"
    if [ "$is_wait" = "Y" ];then
        $mydumper -u $dump_user -p $dump_pass -h $src_host -P $src_port -c -v 3 -t 4 -s 1000000 -r 1000000 -o $backup_path >> $normal_log 2>&1
    else
        $mydumper -u $dump_user -p $dump_pass -h $src_host -P $src_port -c -v 3 -t 4 -s 1000000 -r 1000000 -o $backup_path >> $normal_log 2>&1 &
    fi
    if (($?==0));then
        return 0
    else
        return 64
    fi
}



#######################################
# xtrabackup备份
# Globals:
#   None
# Arguments:
# is_wait 
#   Y:等待备份执行完,适用于在线搭建备机
#   N:不等待备份执行完,置于后台,适用于全备
# Returns:
#   0:Succ
#   64:Fail
function xtrabackBackupLocal()
{
    src_host="$1"
    src_port="$2"
    dest_host="$3"
    dest_port="$4"
    backup_path="$5"
    is_wait="$6"
    normal_log="$7"

    xtrabackupCheck $src_host $src_port $dest_host $dest_port $backup_path $src_ssh_port $dest_ssh_port $normal_log
    if (($?!=0));then
        return 64
    fi

    tmp_dir="/tmp/mysql_backup/full_${src_host}_${src_port}_${RANDOM}/" && mkdir -p $tmp_dir
    ssh -p $src_ssh_port -oStrictHostKeyChecking=no root@$src_host "mkdir -p $tmp_dir"
    #Tips
    # datadir:/data/mysql
    # my.cnf:/data/mysql/port/my.cnf
    # backup.tar
    my_cnf="/data/mysql/${src_port}/my.cnf"
    xtrbackp_cmd="$innobackupex \
--defaults-file=$my_cnf --user=$dump_user --password=$dump_pass --host=$src_host --port=$src_port \
--slave-info \
--no-timestamp \
$tmp_dir --tmpdir=$tmp_dir \
--stream=tar | ssh -p $dest_ssh_port root@$dest_host  \"cat - > ${backup_path}/backup.tar \" "
    if [ "$is_wait" = "Y" ];then
        ssh -p $src_ssh_port -oStrictHostKeyChecking=no root@$src_host "$xtrbackp_cmd" >>$normal_log 2>&1
    else
        ssh -p $src_ssh_port -oStrictHostKeyChecking=no root@$src_host "$xtrbackp_cmd" >>$normal_log 2>&1 &
    fi
}




#######################################
# mydumper备份检测
# Globals:
#   None
# Arguments:
# f_metadata
# Returns:
#   0:Succ
#   1:Backing
#   2:Fail
# 判断成功的逻辑是是否存在metadata
function mydumperResultCheck()
{
    f_metadata="$1"
    if [ -f "$f_metadata" ];then
        return_info="备份成功"
        f_start_time=$(cat "$f_metadata" | grep -w "Started dump at:"| awk -F"Started dump at: " '{print $2}')
        f_end_time=$(cat "$f_metadata" | grep -w "Finished dump at:"| awk -F"Finished dump at: " '{print $2}')
        f_slave_host=$(echo "$data_source"| awk -F":" '{print $1}')
        f_slave_port=$(echo "$data_source"| awk -F":" '{print $2}')
        f_slave_log_file=$(cat "$f_metadata"| grep -w "SHOW MASTER STATUS:" -A 3 | grep -w "Log:"| awk -F"Log:" '{print $2}' | sed 's/ //g')
        f_slave_log_pos=$(cat "$f_metadata"| grep -w "SHOW MASTER STATUS:" -A 3 | grep -w "Pos:"| awk -F"Pos:" '{print $2}' | sed 's/ //g')
        f_slave_gtid=$(cat "$f_metadata"| grep -w "SHOW MASTER STATUS:" -A 3 | grep -w "GTID:"| awk -F"GTID:" '{print $2}' | sed 's/ //g')
        f_master_host=$(cat "$f_metadata"| grep -w "SHOW SLAVE STATUS:" -A 4 | grep -w "Host:"| awk -F"Host:" '{print $2}' | sed 's/ //g')
        repl_conn="$mysql -u$repl_user -p$repl_pass -h$f_slave_host -P$f_slave_port"
        f_master_port=$(echo "show slave status\G" | $repl_conn | grep -w "Master_Port:"| awk -F"Master_Port:" '{print $2}'| sed 's/ //g')
        f_master_log_file=$(cat "$f_metadata"| grep -w "SHOW SLAVE STATUS:" -A 4 | grep -w "Log:"| awk -F"Log:" '{print $2}' | sed 's/ //g')
        f_master_log_pos=$(cat "$f_metadata"| grep -w "SHOW SLAVE STATUS:" -A 4 | grep -w "Pos:"| awk -F"Pos:" '{print $2}' | sed 's/ //g')
        f_master_gtid=$(cat "$f_metadata"| grep -w "SHOW SLAVE STATUS:" -A 4 | grep -w "GTID:"| awk -F"GTID:" '{print $2}' | sed 's/ //g')
        metadata_jason="{'start_time':'$f_start_time','end_time':'$f_end_time','slave_host':'$f_slave_host','slave_port':'$f_slave_port','slave_log_file':'$f_slave_log_file','slave_log_pos':'$f_slave_log_pos','slave_gtid':'$f_slave_gtid','master_host':'$f_master_host','master_port':'$f_master_port','master_log_file':'$f_master_log_file','master_log_pos':'$f_master_log_pos','master_gitd':'$f_master_gtid'}"
        size=$(du -shm $backup_path | awk '{print $1}') 
        E_VALUE=0
    else
        if ps -ef | grep -v grep | grep "mydumper" | grep -q "$backup_path" ;then
            return_info="备份中"
            E_VALUE=1
        else
            return_info="备份失败,找不到$f_metadata"
            E_VALUE=2
        fi
    fi
    return $E_VALUE
}



#function xtrabackupResultCheck()
#{
#    # 检测逻辑,检测备份tar包下是否有xtrabackup_info文件,有则成功
#    # 备份文件写死为backup.tar
#    backup_tar="$1"
#    backup_path=$(dirname "$backup_tar") # 备份路径
#    backup_file=$(basename "$backup_tar") # 备份文件,按理说写死了backup.tar
#    echo "$backup_path,$backup_file"
#    exit
#    if tar -tf $backup_path/$backup_file xtrabackup_info >>$normal_log 2>&1 ;then
#        # Tips:这里cd到另外一个目录了
#        cd $backup_path && tar -xvf $backup_file xtrabackup_info
#        f_start_time=$(cat xtrabackup_info | grep -w "start_time"| awk -F"= " '{print $2}')
#        f_end_time=$(cat xtrabackup_info | grep -w "end_time"| awk -F"= " '{print $2}')
#        f_slave_host=$(echo "$data_source" | awk -F":" '{print $1}')
#        f_slave_port=$(echo "$data_source" | awk -F":" '{print $2}')
#        f_slave_log_file=$(cat xtrabackup_info | grep -w "binlog_pos"| awk -F"= " '{print $2}'| awk -F"," '{print $1}'| awk '{print $2}'| sed "s/'//g")
#        f_slave_log_pos=$(cat xtrabackup_info | grep -w "binlog_pos"| awk -F"= " '{print $2}'| awk -F"," '{print $2}'| awk '{print $2}'| sed "s/'//g")
#        metadata_jason="{'start_time':'$f_start_time','end_time':'$f_end_time','slave_host':'$f_slave_host','slave_port':'$f_slave_port','slave_log_file':'$f_slave_log_file','slave_log_pos':'$f_slave_log_pos','slave_gtid':'','master_host':'','master_port':'','master_log_file':'','master_log_pos':'','master_gitd':''}"
#        size=$(du -shm $backup_path | awk '{print $1}') 
#        return_info="备份成功"
#        E_VALUE=0
#    else
#        if [ -f "$backup_path/$backup_file" ];then
#            return_info="备份中"
#            E_VALUE=1
#        else
#            return_info="备份失败,找不到$backup_tar"
#            E_VALUE=2
#        fi
#        return $E_VALUE
#    fi
#}
